/*@preserve!
 * chartjs-plugin-annotation.js
 * http://chartjs.org/
 * Version: 0.5.7
 *
 * Copyright 2016 Evert Timberg
 * Released under the MIT license
 * https://github.com/chartjs/Chart.Annotation.js/blob/master/LICENSE.md
 */
!(function i(a, o, l) {
  function r(t, e) {
    if (!o[t]) {
      if (!a[t]) {
        var n = 'function' == typeof require && require;
        if (!e && n) return n(t, !0);
        if (s) return s(t, !0);
        throw (
          (((n = new Error("Cannot find module '" + t + "'")).code =
            'MODULE_NOT_FOUND'),
          n)
        );
      }
      (n = o[t] = { exports: {} }),
        a[t][0].call(
          n.exports,
          function (e) {
            return r(a[t][1][e] || e);
          },
          n,
          n.exports,
          i,
          a,
          o,
          l
        );
    }
    return o[t].exports;
  }
  for (
    var s = 'function' == typeof require && require, e = 0;
    e < l.length;
    e++
  )
    r(l[e]);
  return r;
})(
  {
    1: [function (e, t, n) {}, {}],
    2: [
      function (n, e, t) {
        e.exports = function (e) {
          var a = e.helpers,
            l = n('./helpers.js')(e),
            o = n('./events.js')(e),
            r = e.Annotation.types;
          function i(e) {
            l.decorate(e, 'afterDataLimits', function (e, t) {
              e && e(t), l.adjustScaleRange(t);
            });
          }
          function t(i) {
            return function (e, t) {
              var n = e.annotation.options.drawTime;
              l.elements(e)
                .filter(function (e) {
                  return i === (e.options.drawTime || n);
                })
                .forEach(function (e) {
                  e.configure(), e.transition(t).draw();
                });
            };
          }
          function s(e) {
            var t = e.plugins;
            return (
              (t && t.annotation ? t.annotation : null) || e.annotation || {}
            );
          }
          return {
            id: 'annotation',
            beforeInit: function (e) {
              var t = e.options,
                n = (e.annotation = {
                  elements: {},
                  options: l.initConfig(s(t)),
                  onDestroy: [],
                  firstRun: !0,
                  supported: !1,
                });
              e.ensureScalesHaveIDs(),
                t.scales &&
                  ((n.supported = !0),
                  a.each(t.scales.xAxes, i),
                  a.each(t.scales.yAxes, i));
            },
            beforeUpdate: function (i) {
              var a,
                o = i.annotation;
              o.supported &&
                (o.firstRun
                  ? (o.firstRun = !1)
                  : (o.options = l.initConfig(s(i.options))),
                (a = []),
                o.options.annotations.forEach(function (e) {
                  var t,
                    n = e.id || l.objectId();
                  !o.elements[n] && r[e.type]
                    ? ((t = new r[e.type]({
                        id: n,
                        options: e,
                        chartInstance: i,
                      })).initialize(),
                      (o.elements[n] = t),
                      (e.id = n),
                      a.push(n))
                    : o.elements[n] && a.push(n);
                }),
                Object.keys(o.elements).forEach(function (e) {
                  -1 === a.indexOf(e) &&
                    (o.elements[e].destroy(), delete o.elements[e]);
                }));
            },
            beforeDatasetsDraw: t('beforeDatasetsDraw'),
            afterDatasetsDraw: t('afterDatasetsDraw'),
            afterDraw: t('afterDraw'),
            afterInit: function (t) {
              var n,
                i,
                e = t.annotation.options.events;
              a.isArray(e) &&
                0 < e.length &&
                ((n = t.chart.canvas),
                (i = o.dispatcher.bind(t)),
                o.collapseHoverEvents(e).forEach(function (e) {
                  a.addEvent(n, e, i),
                    t.annotation.onDestroy.push(function () {
                      a.removeEvent(n, e, i);
                    });
                }));
            },
            destroy: function (e) {
              if (e && e.annotation)
                for (var t = e.annotation.onDestroy; 0 < t.length; ) t.pop()();
            },
          };
        };
      },
      { './events.js': 4, './helpers.js': 5 },
    ],
    3: [
      function (e, t, n) {
        t.exports = function (e) {
          var t = e.helpers;
          return e.Element.extend({
            initialize: function () {
              (this.hidden = !1),
                (this.hovering = !1),
                (this._model = t.clone(this._model) || {}),
                this.setDataLimits();
            },
            destroy: function () {},
            setDataLimits: function () {},
            configure: function () {},
            inRange: function () {},
            getCenterPoint: function () {},
            getWidth: function () {},
            getHeight: function () {},
            getArea: function () {},
            draw: function () {},
          });
        };
      },
      {},
    ],
    4: [
      function (t, e, n) {
        e.exports = function (e) {
          var s = e.helpers,
            c = t('./helpers.js')(e);
          function u(e) {
            var t = !1,
              e = e.filter(function (e) {
                switch (e) {
                  case 'mouseenter':
                  case 'mouseover':
                  case 'mouseout':
                  case 'mouseleave':
                    return !(t = !0);
                  default:
                    return !0;
                }
              });
            return t && -1 === e.indexOf('mousemove') && e.push('mousemove'), e;
          }
          return {
            dispatcher: function (a) {
              var e = this.annotation,
                t = c.elements(this),
                n = s.getRelativePosition(a, this.chart),
                i = c.getNearestItems(t, n),
                o = u(e.options.events),
                n = e.options.dblClickSpeed,
                l = [],
                e = c.getEventHandlerName(a.type),
                r = (i || {}).options;
              if (
                ('mousemove' === a.type &&
                  (i && !i.hovering
                    ? ['mouseenter', 'mouseover'].forEach(function (e) {
                        var t = c.getEventHandlerName(e),
                          e = c.createMouseEvent(e, a);
                        (i.hovering = !0),
                          'function' == typeof r[t] && l.push([r[t], e, i]);
                      })
                    : i ||
                      t.forEach(function (n) {
                        var i;
                        n.hovering &&
                          ((n.hovering = !1),
                          (i = n.options),
                          ['mouseout', 'mouseleave'].forEach(function (e) {
                            var t = c.getEventHandlerName(e),
                              e = c.createMouseEvent(e, a);
                            'function' == typeof i[t] && l.push([i[t], e, n]);
                          }));
                      })),
                i &&
                  -1 < o.indexOf('dblclick') &&
                  'function' == typeof r.onDblclick)
              ) {
                if ('click' === a.type && 'function' == typeof r.onClick)
                  return (
                    clearTimeout(i.clickTimeout),
                    (i.clickTimeout = setTimeout(function () {
                      delete i.clickTimeout, r.onClick.call(i, a);
                    }, n)),
                    a.stopImmediatePropagation(),
                    void a.preventDefault()
                  );
                'dblclick' === a.type &&
                  i.clickTimeout &&
                  (clearTimeout(i.clickTimeout), delete i.clickTimeout);
              }
              i &&
                'function' == typeof r[e] &&
                0 === l.length &&
                l.push([r[e], a, i]),
                0 < l.length &&
                  (a.stopImmediatePropagation(),
                  a.preventDefault(),
                  l.forEach(function (e) {
                    e[0].call(e[2], e[1]);
                  }));
            },
            collapseHoverEvents: u,
          };
        };
      },
      { './helpers.js': 5 },
    ],
    5: [
      function (e, t, n) {
        function i() {}
        function l(e) {
          var t = e.annotation.elements;
          return Object.keys(t).map(function (e) {
            return t[e];
          });
        }
        function a() {
          return Math.random().toString(36).substr(2, 6);
        }
        function r(e) {
          return null != e && ('number' == typeof e ? isFinite(e) : !!e);
        }
        function s(t, n, i) {
          t['$' + n] ||
            (t[n]
              ? ((t['$' + n] = t[n].bind(t)),
                (t[n] = function () {
                  var e = [t['$' + n]].concat(
                    Array.prototype.slice.call(arguments)
                  );
                  return i.apply(t, e);
                }))
              : (t[n] = function () {
                  var e = [void 0].concat(
                    Array.prototype.slice.call(arguments)
                  );
                  return i.apply(t, e);
                }));
        }
        function c(e, t) {
          e.forEach(function (e) {
            (t ? e[t] : e)();
          });
        }
        function u(e) {
          return 'on' + e[0].toUpperCase() + e.substring(1);
        }
        function d(t, n) {
          try {
            return new MouseEvent(t, n);
          } catch (e) {
            try {
              var i = document.createEvent('MouseEvent');
              return (
                i.initMouseEvent(
                  t,
                  n.canBubble,
                  n.cancelable,
                  n.view,
                  n.detail,
                  n.screenX,
                  n.screenY,
                  n.clientX,
                  n.clientY,
                  n.ctrlKey,
                  n.altKey,
                  n.shiftKey,
                  n.metaKey,
                  n.button,
                  n.relatedTarget
                ),
                i
              );
            } catch (e) {
              var a = document.createEvent('Event');
              return a.initEvent(t, n.canBubble, n.cancelable), a;
            }
          }
        }
        t.exports = function (t) {
          var o = t.helpers;
          return {
            initConfig: function (e) {
              return (
                (e = o.configMerge(t.Annotation.defaults, e)),
                o.isArray(e.annotations) &&
                  e.annotations.forEach(function (e) {
                    e.label = o.configMerge(
                      t.Annotation.labelDefaults,
                      e.label
                    );
                  }),
                e
              );
            },
            elements: l,
            callEach: c,
            noop: i,
            objectId: a,
            isValid: r,
            decorate: s,
            adjustScaleRange: function (e) {
              var t,
                n,
                i,
                a =
                  ((t = e.id),
                  (n = l(e.chart)),
                  (i = e.min),
                  (a = e.max),
                  {
                    min: (n = n
                      .filter(function (e) {
                        return !!e._model.ranges[t];
                      })
                      .map(function (e) {
                        return e._model.ranges[t];
                      }))
                      .map(function (e) {
                        return Number(e.min);
                      })
                      .reduce(function (e, t) {
                        return isFinite(t) && !isNaN(t) && t < e ? t : e;
                      }, i),
                    max: n
                      .map(function (e) {
                        return Number(e.max);
                      })
                      .reduce(function (e, t) {
                        return isFinite(t) && !isNaN(t) && e < t ? t : e;
                      }, a),
                  });
              void 0 === e.options.ticks.min &&
                void 0 === e.options.ticks.suggestedMin &&
                (e.min = a.min),
                void 0 === e.options.ticks.max &&
                  void 0 === e.options.ticks.suggestedMax &&
                  (e.max = a.max),
                e.handleTickRangeOptions && e.handleTickRangeOptions();
            },
            getNearestItems: function (e, i) {
              var a = Number.POSITIVE_INFINITY;
              return e
                .filter(function (e) {
                  return e.inRange(i.x, i.y);
                })
                .reduce(function (e, t) {
                  var n = t.getCenterPoint(),
                    n = o.distanceBetweenPoints(i, n);
                  return n < a ? ((e = [t]), (a = n)) : n === a && e.push(t), e;
                }, [])
                .sort(function (e, t) {
                  var n = e.getArea(),
                    i = t.getArea();
                  return i < n || n < i ? n - i : e._index - t._index;
                })
                .slice(0, 1)[0];
            },
            getEventHandlerName: u,
            createMouseEvent: d,
          };
        };
      },
      {},
    ],
    6: [
      function (e, t, n) {
        var i = e('chart.js');
        ((i = 'function' == typeof i ? i : window.Chart).Annotation =
          i.Annotation || {}),
          (i.Annotation.drawTimeOptions = {
            afterDraw: 'afterDraw',
            afterDatasetsDraw: 'afterDatasetsDraw',
            beforeDatasetsDraw: 'beforeDatasetsDraw',
          }),
          (i.Annotation.defaults = {
            drawTime: 'afterDatasetsDraw',
            dblClickSpeed: 350,
            events: [],
            annotations: [],
          }),
          (i.Annotation.labelDefaults = {
            backgroundColor: 'rgba(0,0,0,0.8)',
            fontFamily: i.defaults.global.defaultFontFamily,
            fontSize: i.defaults.global.defaultFontSize,
            fontStyle: 'bold',
            fontColor: '#fff',
            xPadding: 6,
            yPadding: 6,
            cornerRadius: 6,
            position: 'center',
            xAdjust: 0,
            yAdjust: 0,
            enabled: !1,
            content: null,
          }),
          (i.Annotation.Element = e('./element.js')(i)),
          (i.Annotation.types = {
            line: e('./types/line.js')(i),
            box: e('./types/box.js')(i),
          });
        e = e('./annotation.js')(i);
        (t.exports = e), i.pluginService.register(e);
      },
      {
        './annotation.js': 2,
        './element.js': 3,
        './types/box.js': 7,
        './types/line.js': 8,
        'chart.js': 1,
      },
    ],
    7: [
      function (t, e, n) {
        e.exports = function (e) {
          var d = t('../helpers.js')(e);
          return e.Annotation.Element.extend({
            setDataLimits: function () {
              var e,
                t = this._model,
                n = this.options,
                i = this.chartInstance,
                a = i.scales[n.xScaleID],
                o = i.scales[n.yScaleID],
                l = i.chartArea;
              (t.ranges = {}),
                l &&
                  ((i = e = 0),
                  a &&
                    ((e = d.isValid(n.xMin)
                      ? n.xMin
                      : a.getValueForPixel(l.left)),
                    (i = d.isValid(n.xMax)
                      ? n.xMax
                      : a.getValueForPixel(l.right)),
                    (t.ranges[n.xScaleID] = {
                      min: Math.min(e, i),
                      max: Math.max(e, i),
                    })),
                  o &&
                    ((e = d.isValid(n.yMin)
                      ? n.yMin
                      : o.getValueForPixel(l.bottom)),
                    (i = d.isValid(n.yMax)
                      ? n.yMax
                      : o.getValueForPixel(l.top)),
                    (t.ranges[n.yScaleID] = {
                      min: Math.min(e, i),
                      max: Math.max(e, i),
                    })));
            },
            configure: function () {
              var e = this._model,
                t = this.options,
                n = this.chartInstance,
                i = n.scales[t.xScaleID],
                a = n.scales[t.yScaleID],
                o = n.chartArea;
              e.clip = { x1: o.left, x2: o.right, y1: o.top, y2: o.bottom };
              var l,
                r,
                s = o.left,
                c = o.top,
                u = o.right,
                n = o.bottom;
              i &&
                ((l = d.isValid(t.xMin) ? i.getPixelForValue(t.xMin) : o.left),
                (r = d.isValid(t.xMax) ? i.getPixelForValue(t.xMax) : o.right),
                (s = Math.min(l, r)),
                (u = Math.max(l, r))),
                a &&
                  ((l = d.isValid(t.yMin)
                    ? a.getPixelForValue(t.yMin)
                    : o.bottom),
                  (r = d.isValid(t.yMax) ? a.getPixelForValue(t.yMax) : o.top),
                  (c = Math.min(l, r)),
                  (n = Math.max(l, r))),
                (e.left = s),
                (e.top = c),
                (e.right = u),
                (e.bottom = n),
                (e.borderColor = t.borderColor),
                (e.borderWidth = t.borderWidth),
                (e.backgroundColor = t.backgroundColor);
            },
            inRange: function (e, t) {
              var n = this._model;
              return (
                n && e >= n.left && e <= n.right && t >= n.top && t <= n.bottom
              );
            },
            getCenterPoint: function () {
              var e = this._model;
              return { x: (e.right + e.left) / 2, y: (e.bottom + e.top) / 2 };
            },
            getWidth: function () {
              var e = this._model;
              return Math.abs(e.right - e.left);
            },
            getHeight: function () {
              var e = this._model;
              return Math.abs(e.bottom - e.top);
            },
            getArea: function () {
              return this.getWidth() * this.getHeight();
            },
            draw: function () {
              var e = this._view,
                t = this.chartInstance.chart.ctx;
              t.save(),
                t.beginPath(),
                t.rect(
                  e.clip.x1,
                  e.clip.y1,
                  e.clip.x2 - e.clip.x1,
                  e.clip.y2 - e.clip.y1
                ),
                t.clip(),
                (t.lineWidth = e.borderWidth),
                (t.strokeStyle = e.borderColor),
                (t.fillStyle = e.backgroundColor);
              var n = e.right - e.left,
                i = e.bottom - e.top;
              t.fillRect(e.left, e.top, n, i),
                t.strokeRect(e.left, e.top, n, i),
                t.restore();
            },
          });
        };
      },
      { '../helpers.js': 5 },
    ],
    8: [
      function (t, e, n) {
        e.exports = function (e) {
          var r = e.helpers,
            s = t('../helpers.js')(e),
            c = 'horizontal',
            u = 'vertical';
          function d(t) {
            var n = (t.x2 - t.x1) / (t.y2 - t.y1),
              i = t.x1 || 0;
            (this.m = n),
              (this.b = i),
              (this.getX = function (e) {
                return n * (e - t.y1) + i;
              }),
              (this.getY = function (e) {
                return (e - i) / n + t.y1;
              }),
              (this.intersects = function (e, t, n) {
                n = n || 0.001;
                var i = this.getY(e),
                  a = this.getX(t);
                return (
                  (!isFinite(i) || Math.abs(t - i) < n) &&
                  (!isFinite(a) || Math.abs(e - a) < n)
                );
              });
          }
          return e.Annotation.Element.extend({
            setDataLimits: function () {
              var e = this._model,
                t = this.options;
              (e.ranges = {}),
                (e.ranges[t.scaleID] = {
                  min: t.value,
                  max: t.endValue || t.value,
                });
            },
            configure: function () {
              var e,
                t,
                n = this._model,
                i = this.options,
                a = this.chartInstance,
                o = a.chart.ctx,
                l = a.scales[i.scaleID];
              l &&
                ((t = s.isValid(i.value)
                  ? l.getPixelForValue(i.value, i.value.index)
                  : NaN),
                (e = s.isValid(i.endValue)
                  ? l.getPixelForValue(i.endValue, i.value.index)
                  : t)),
                isNaN(t) ||
                  ((a = a.chartArea),
                  (n.clip = {
                    x1: a.left,
                    x2: a.right,
                    y1: a.top,
                    y2: a.bottom,
                  }),
                  this.options.mode === c
                    ? ((n.x1 = a.left),
                      (n.x2 = a.right),
                      (n.y1 = t),
                      (n.y2 = e))
                    : ((n.y1 = a.top),
                      (n.y2 = a.bottom),
                      (n.x1 = t),
                      (n.x2 = e)),
                  (n.line = new d(n)),
                  (n.mode = i.mode),
                  (n.labelBackgroundColor = i.label.backgroundColor),
                  (n.labelFontFamily = i.label.fontFamily),
                  (n.labelFontSize = i.label.fontSize),
                  (n.labelFontStyle = i.label.fontStyle),
                  (n.labelFontColor = i.label.fontColor),
                  (n.labelXPadding = i.label.xPadding),
                  (n.labelYPadding = i.label.yPadding),
                  (n.labelCornerRadius = i.label.cornerRadius),
                  (n.labelPosition = i.label.position),
                  (n.labelXAdjust = i.label.xAdjust),
                  (n.labelYAdjust = i.label.yAdjust),
                  (n.labelEnabled = i.label.enabled),
                  (n.labelContent = i.label.content),
                  (n.labelRotation = i.label.rotation),
                  (o.font = r.fontString(
                    n.labelFontSize,
                    n.labelFontStyle,
                    n.labelFontFamily
                  )),
                  (a = o.measureText(n.labelContent).width),
                  (t = n.labelFontSize),
                  (n.labelHeight = t + 2 * n.labelYPadding),
                  n.labelContent &&
                    r.isArray(n.labelContent) &&
                    ((e = n.labelContent.slice(0).sort(function (e, t) {
                      return t.length - e.length;
                    })[0]),
                    (a = o.measureText(e).width),
                    (n.labelHeight =
                      t * n.labelContent.length + 2 * n.labelYPadding),
                    (n.labelHeight +=
                      n.labelYPadding * (n.labelContent.length - 1))),
                  (t = (function (e, t, n, i, a) {
                    var o = e.line,
                      l = {},
                      r = 0,
                      s = 0;
                    switch (!0) {
                      case e.mode === u && 'top' === e.labelPosition:
                        (s = a + e.labelYAdjust),
                          (r = t / 2 + e.labelXAdjust),
                          (l.y = e.y1 + s),
                          (l.x = (isFinite(o.m) ? o.getX(l.y) : e.x1) - r);
                        break;
                      case e.mode === u && 'bottom' === e.labelPosition:
                        (s = n + a + e.labelYAdjust),
                          (r = t / 2 + e.labelXAdjust),
                          (l.y = e.y2 - s),
                          (l.x = (isFinite(o.m) ? o.getX(l.y) : e.x1) - r);
                        break;
                      case e.mode === c && 'left' === e.labelPosition:
                        (r = i + e.labelXAdjust),
                          (s = -n / 2 + e.labelYAdjust),
                          (l.x = e.x1 + r),
                          (l.y = o.getY(l.x) + s);
                        break;
                      case e.mode === c && 'right' === e.labelPosition:
                        (r = t + i + e.labelXAdjust),
                          (s = -n / 2 + e.labelYAdjust),
                          (l.x = e.x2 - r),
                          (l.y = o.getY(l.x) + s);
                        break;
                      default:
                        (l.x = (e.x1 + e.x2 - t) / 2 + e.labelXAdjust),
                          (l.y = (e.y1 + e.y2 - n) / 2 + e.labelYAdjust);
                    }
                    return l;
                  })(n, a, t, n.labelXPadding, n.labelYPadding)),
                  (n.labelX = t.x - n.labelXPadding),
                  (n.labelY = t.y - n.labelYPadding),
                  (n.labelWidth = a + 2 * n.labelXPadding),
                  (n.borderColor = i.borderColor),
                  (n.borderWidth = i.borderWidth),
                  (n.borderDash = i.borderDash || []),
                  (n.borderDashOffset = i.borderDashOffset || 0));
            },
            inRange: function (e, t) {
              var n = this._model;
              return (
                (n.line && n.line.intersects(e, t, this.getHeight())) ||
                (n.labelEnabled &&
                  n.labelContent &&
                  e >= n.labelX &&
                  e <= n.labelX + n.labelWidth &&
                  t >= n.labelY &&
                  t <= n.labelY + n.labelHeight)
              );
            },
            getCenterPoint: function () {
              return {
                x: (this._model.x2 + this._model.x1) / 2,
                y: (this._model.y2 + this._model.y1) / 2,
              };
            },
            getWidth: function () {
              return Math.abs(this._model.right - this._model.left);
            },
            getHeight: function () {
              return this._model.borderWidth || 1;
            },
            getArea: function () {
              return Math.sqrt(
                Math.pow(this.getWidth(), 2) + Math.pow(this.getHeight(), 2)
              );
            },
            draw: function () {
              var e = this._view,
                t = this.chartInstance.chart.ctx;
              if (e.clip) {
                if (
                  (t.save(),
                  t.beginPath(),
                  t.rect(
                    e.clip.x1,
                    e.clip.y1,
                    e.clip.x2 - e.clip.x1,
                    e.clip.y2 - e.clip.y1
                  ),
                  t.clip(),
                  (t.lineWidth = e.borderWidth),
                  (t.strokeStyle = e.borderColor),
                  t.setLineDash && t.setLineDash(e.borderDash),
                  (t.lineDashOffset = e.borderDashOffset),
                  t.beginPath(),
                  t.moveTo(e.x1, e.y1),
                  t.lineTo(e.x2, e.y2),
                  t.stroke(),
                  e.labelEnabled && e.labelContent)
                )
                  if (
                    (t.beginPath(),
                    t.rect(
                      e.clip.x1,
                      e.clip.y1,
                      e.clip.x2 - e.clip.x1,
                      e.clip.y2 - e.clip.y1
                    ),
                    t.clip(),
                    t.translate(
                      e.labelX + e.labelWidth / 2,
                      e.labelY + e.labelHeight / 2
                    ),
                    t.rotate((e.labelRotation * Math.PI) / 180),
                    (t.fillStyle = e.labelBackgroundColor),
                    r.drawRoundedRectangle(
                      t,
                      -e.labelWidth / 2,
                      -e.labelHeight / 2,
                      e.labelWidth,
                      e.labelHeight,
                      e.labelCornerRadius
                    ),
                    t.fill(),
                    (t.font = r.fontString(
                      e.labelFontSize,
                      e.labelFontStyle,
                      e.labelFontFamily
                    )),
                    (t.fillStyle = e.labelFontColor),
                    (t.textAlign = 'center'),
                    e.labelContent && r.isArray(e.labelContent))
                  )
                    for (
                      var n = -e.labelHeight / 2 + e.labelYPadding, i = 0;
                      i < e.labelContent.length;
                      i++
                    )
                      (t.textBaseline = 'top'),
                        t.fillText(
                          e.labelContent[i],
                          -e.labelWidth / 2 + e.labelWidth / 2,
                          n
                        ),
                        (n += e.labelFontSize + e.labelYPadding);
                  else
                    (t.textBaseline = 'middle'),
                      t.fillText(e.labelContent, 0, 0);
                t.restore();
              }
            },
          });
        };
      },
      { '../helpers.js': 5 },
    ],
  },
  {},
  [6]
);
